import { ChainOrRpc } from "../constants";
import { SmartContract } from "../contracts/smart-contract";
import { SDKOptions } from "../schema/sdk-options";
import { CurrencyValue } from "../types/index";
import { WalletAuthenticator } from "./auth/wallet-authenticator";
import { ContractDeployer } from "./classes/contract-deployer";
import { ContractPublisher } from "./classes/contract-publisher";
import { RPCConnectionHandler } from "./classes/rpc-connection-handler";
import type { ContractForPrebuiltContractType, ContractType, NetworkOrSignerOrProvider, PrebuiltContractType, SignerOrProvider } from "./types";
import { UserWallet } from "./wallet/UserWallet";
import { RemoteStorage, IStorage } from "@thirdweb-dev/storage";
import { ContractInterface, ethers, Signer } from "ethers";
/**
 * The main entry point for the thirdweb SDK
 * @public
 */
export declare class ThirdwebSDK extends RPCConnectionHandler {
    /**
     * Get an instance of the thirdweb SDK based on an existing ethers signer
     *
     * @example
     * ```javascript
     * // get a signer from somewhere (createRandom is being used purely for example purposes)
     * const signer = ethers.Wallet.createRandom();
     *
     * // get an instance of the SDK with the signer already setup
     * const sdk = ThirdwebSDK.fromSigner(signer, "mainnet");
     * ```
     *
     * @param signer - a ethers Signer to be used for transactions
     * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
     * @param options - the SDK options to use
     * @returns an instance of the SDK
     * @param storage - optional storage implementation to use
     *
     * @beta
     */
    static fromSigner(signer: Signer, network?: ChainOrRpc, options?: SDKOptions, storage?: IStorage): ThirdwebSDK;
    /**
     * Get an instance of the thirdweb SDK based on a private key.
     *
     * @remarks
     * This should only be used for backend services or scripts, with the private key stored in a secure way.
     * **NEVER** expose your private key to the public in any way.
     *
     * @example
     * ```javascript
     * const sdk = ThirdwebSDK.fromPrivateKey("SecretPrivateKey", "mainnet");
     * ```
     *
     * @param privateKey - the private key - **DO NOT EXPOSE THIS TO THE PUBLIC**
     * @param network - the network (chain) to connect to (e.g. "mainnet", "rinkeby", "polygon", "mumbai"...) or a fully formed RPC url
     * @param options - the SDK options to use
     * @param storage - optional storage implementation to use
     * @returns an instance of the SDK
     *
     * @beta
     */
    static fromPrivateKey(privateKey: string, network: ChainOrRpc, options?: SDKOptions, storage?: IStorage): ThirdwebSDK;
    /**
     * @internal
     * the cache of contracts that we have already seen
     */
    private contractCache;
    /**
     * @internal
     * should never be accessed directly, use {@link ThirdwebSDK.getPublisher} instead
     */
    private _publisher;
    /**
     * Internal handler for uploading and downloading files
     */
    private storageHandler;
    /**
     * New contract deployer
     */
    deployer: ContractDeployer;
    /**
     * Interact with the connected wallet
     */
    wallet: UserWallet;
    /**
     * Upload and download files from IPFS or from your own storage service
     */
    storage: RemoteStorage;
    /**
     * Enable authentication with the connected wallet
     */
    auth: WalletAuthenticator;
    constructor(network: ChainOrRpc | SignerOrProvider, options?: SDKOptions, storage?: IStorage);
    /**
     * Get an instance of a Drop contract
     * @param contractAddress - the address of the deployed contract
     * @returns the contract
     */
    getNFTDrop(contractAddress: string): Promise<import("../contracts/prebuilt-implementations/nft-drop").NFTDropImpl>;
    /**
     * Get an instance of a SignatureDrop contract
     * @param contractAddress - the address of the deployed contract
     * @returns the contract
     */
    getSignatureDrop(contractAddress: string): Promise<import("../contracts/prebuilt-implementations/signature-drop").SignatureDropImpl>;
    /**
     * Get an instance of a NFT Collection contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getNFTCollection(address: string): Promise<import("../contracts/prebuilt-implementations/nft-collection").NFTCollectionImpl>;
    /**
     * Get an instance of a Edition Drop contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getEditionDrop(address: string): Promise<import("../contracts/prebuilt-implementations/edition-drop").EditionDropImpl>;
    /**
     * Get an instance of an Edition contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getEdition(address: string): Promise<import("../contracts/prebuilt-implementations/edition").EditionImpl>;
    /**
     * Get an instance of a Token Drop contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getTokenDrop(address: string): Promise<import("../contracts/prebuilt-implementations/token-drop").TokenDropImpl>;
    /**
     * Get an instance of a Token contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getToken(address: string): Promise<import("../contracts/prebuilt-implementations/token").TokenImpl>;
    /**
     * Get an instance of a Vote contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getVote(address: string): Promise<import("../contracts/prebuilt-implementations/vote").VoteImpl>;
    /**
     * Get an instance of a Splits contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getSplit(address: string): Promise<import("../contracts/prebuilt-implementations/split").SplitImpl>;
    /**
     * Get an instance of a Marketplace contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getMarketplace(address: string): Promise<import("../contracts/prebuilt-implementations/marketplace").MarketplaceImpl>;
    /**
     * Get an instance of a Pack contract
     * @param address - the address of the deployed contract
     * @returns the contract
     */
    getPack(address: string): Promise<import("../contracts/prebuilt-implementations/pack").PackImpl>;
    /**
     * Get an instance of a Multiwrap contract
     * @param address - the address of the deployed contract
     * @returns the contract
     * @beta
     */
    getMultiwrap(address: string): Promise<import("../contracts/prebuilt-implementations/multiwrap").MultiwrapImpl>;
    /**
     *
     * @internal
     * @param address - the address of the contract to instantiate
     * @param contractType - optional, the type of contract to instantiate
     * @returns a promise that resolves with the contract instance
     */
    getBuiltInContract<TContractType extends PrebuiltContractType = PrebuiltContractType>(address: string, contractType: TContractType): Promise<ContractForPrebuiltContractType<TContractType>>;
    /**
     * @param contractAddress - the address of the contract to attempt to resolve the contract type for
     * @returns the {@link ContractType} for the given contract address
     *
     */
    resolveContractType(contractAddress: string): Promise<ContractType>;
    /**
     * Return all the contracts deployed by the specified address
     * @param walletAddress - the deployed address
     * @example
     * ```javascript
     * const contracts = sdk.getContractList("{{wallet_address}}");
     * ```
     */
    getContractList(walletAddress: string): Promise<{
        address: string;
        contractType: "edition-drop" | "custom" | "edition" | "marketplace" | "multiwrap" | "nft-collection" | "nft-drop" | "pack" | "signature-drop" | "split" | "token-drop" | "token" | "vote";
        metadata: () => Promise<any>;
    }[]>;
    /**
     * Update the active signer or provider for all contracts
     * @param network - the new signer or provider
     */
    updateSignerOrProvider(network: NetworkOrSignerOrProvider): void;
    private updateContractSignerOrProvider;
    /**
     * Get an instance of a Custom ThirdwebContract
     * @param address - the address of the deployed contract
     * @returns the contract
     * @beta
     * @example
     * ```javascript
     * const contract = sdk.getContract("{{contract_address}}");
     * ```
     */
    getContract(address: string): Promise<SmartContract<ethers.BaseContract>>;
    /**
     * Get an instance of a Custom contract from a json ABI
     * @param address - the address of the deployed contract
     * @param abi - the JSON abi
     * @returns the contract
     * @beta
     * @example
     * ```javascript
     * // Import your ABI from a JSON file
     * import myABI from "./path/to/myABI.json";
     *
     * const contract = sdk.getContractFromAbi(
     *   "{{contract_address}}",
     *   // Pass in the "abi" field from the JSON file
     *   myABI.abi
     * );
     * ```
     */
    getContractFromAbi(address: string, abi: ContractInterface): SmartContract<ethers.BaseContract>;
    /**
     * Get the native balance of a given address (wallet or contract)
     * @example
     * ```javascript
     * const balance = await sdk.getBalance("0x...");
     * console.log(balance.displayValue);
     * ```
     * @param address - the address to check the balance for
     */
    getBalance(address: string): Promise<CurrencyValue>;
    /**
     * @internal
     */
    getPublisher(): ContractPublisher;
}
//# sourceMappingURL=sdk.d.ts.map